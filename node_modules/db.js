
var DataStore = require('nedb'),
    path = require('path'),
    util = require('utils'),
    WEBR = null,
    datapath = null,
    db = null,
    addedFeeds = 0,
    settings = {
        updateRate: 1000 * 60 * 60, // 1 hour
        lastUpdate: 0,
        removeOlderThan: 1000 * 60 * 60 * 24 * 10, // 10 days
        lastRemove: 0,
        minPosts: 20,
        articleFontSize: 15,
        lineHeight: 1.4,
        articleFont: 'Lato',
        nextSavedFeedId: 1,
        posX: -1,
        posY: -1,
        sizeX: 1200,
        sizeY: 750,
        hue: 0,
        themeId: 0
    },
    suggestions = [ // { name, rss, append, sel, remove }
        {name: 'BBC News', rss: 'http://feeds.bbci.co.uk/news/rss.xml?edition=int', sel: 'div.story-body', remove: 'div.share-help'},
        {name: 'TODAY Online', rss: 'http://www.todayonline.com/taxonomy/term/3/all/feed', append: '?singlepage=true', sel: 'article.article|div.content p'},
        {name: 'ArsTechnica', rss: 'http://feeds.arstechnica.com/arstechnica/index', sel: 'section#article-guts'},
        {name: 'The Verge', rss: 'http://www.theverge.com/rss/full.xml', sel: 'div.m-article__entry|div.m-feature__intro|div.m-feature__body', remove: 'div.m-article__share-buttons'},
        {name: 'Aeon Magazine', rss: 'http://feeds.feedburner.com/AeonMagazineEssays', sel: 'div.masthead-image|div.content', remove: 'div.aeon-popular-panel|div.shortcode-inline-newsletter'},
        {name: 'Nautilus', rss: 'http://nautil.us/rss/all', sel: 'div.page-content'},
        {name: 'XKCD', rss: 'http://www.xkcd.com/rss.xml'},
        {name: 'Merriam-Webster Word of the Day', rss: 'http://www.merriam-webster.com/word/index.xml'},
        {name: 'TED - Youtube', rss: 'http://gdata.youtube.com/feeds/base/users/TEDtalksDirector/uploads?alt=rss&v=2&orderby=published&client=ytapi-youtube-profile'}
    ],
    savedFeed = { name: 'Saved Articles', rss: 'saved' },
    feeds = [ ], // { name, rss, append, sel, remove, lastupdate, lastlink, nextid, unread, read }
    content = {}; // [ id, title, desc, link, date, read ]


exports.db = db;
exports.settings = settings;
exports.suggestions = suggestions;
exports.savedFeed = savedFeed;
exports.feeds = function () { return feeds };
exports.content = content;


// returns a feed object given an RSS URL, or null if none is found
exports.findFeed = function (url) {
    if (!url) return null;
    if (url == 'saved') return savedFeed;
    for (var i in feeds) {
        if (feeds[i].rss == url)
            return feeds[i];
    }
    return null;
}

exports.getFeedIndex = function (feed) {
    if (!feed || feed.url == 'saved') return -1;
    for (var i = 0; i < feeds.length; i++) {
        if (feeds[i].rss == feed.rss) {
            return i;
        }
    }
    return -1;
}

exports.swapFeedsByIndex = function (id1, id2) {
    if (id1 < 0 || id2 < 0 || id1 >= feeds.length || id2 >= feeds.length || id1 == id2) return;
    
    var temp = feeds[id1];
    feeds[id1] = feeds[id2];
    feeds[id2] = temp;
    exports.saveFeedList();
}

// returns a post object given feed url and article url, or null if none is found
exports.findPost = function (feed, articleUrl) {
    if (!feed) return null;
    var posts = content[feed.rss];
    if (!posts || posts.length == 0) {
        return null;
    }
    
    for (var i = 0; i < posts.length; i++) {
        if (posts[i].link == articleUrl)
            return posts[i];
    }
    return null;
}


function isArticleInList(link, posts) {
    if (!link || !posts) {
        return false;
    }
    for (var i = 0; i < posts.length; i++) {
        if (posts[i].link == link) {
            return true;
        }
    }
    return false;
}

function pullFeed(feed) {
    if (!feed || feed.url == 'saved') return;
    if (!feed.nextid) feed.nextid = 1;
    if (feed.read == null) feed.read = 0;
    if (feed.unread == null) feed.unread = 0;
    if (!feed.lastlink) feed.lastlink = '[none]';
    
    function onDone(posts, meta) {
        if (posts.length == 0) {
            return;
        }
        
        // extract data and ensure no duplicates
        var now = new Date().getTime(),
            newPosts = [],
            curPosts = content[feed.rss];
        for (var i = 0; i < posts.length; i++) {
            if (posts[i].link == feed.lastlink) {
                break;
            }
            if (isArticleInList(posts[i].link, curPosts)) {
                continue;
            }
            var p = { title: posts[i].title, desc: posts[i].description, link: posts[i].link, date: posts[i].pubdate };
            if (!p.date) {
                p.date = new Date();
            } else {
                if (p.date.getTime() < now - settings.removeOlderThan)
                    continue;
            }
            newPosts.push(p);
        }
        
        // assign IDs
        if (newPosts.length == 0) {
            return;
        }
        for (var i = newPosts.length - 1; i >= 0; i--) {
            newPosts[i].id = feed.nextid++;
        }
        
        // update stored data
        addedFeeds += newPosts.length;
        feed.lastlink = newPosts[0].link;
        feed.lastupdate = new Date();
        if (curPosts) {
            curPosts = newPosts.concat(curPosts);
            
            // remove old articles
            var updated = [];
            for (var i = 0; i < curPosts.length; i++) {
                if (i >= settings.minPosts && curPosts[i].date.getTime() < now - settings.removeOlderThan)
                    continue;
                updated.push(curPosts[i]);
            }
            content[feed.rss] = updated;
            
        } else {
            content[feed.rss] = newPosts;
        }
        
        // save to database
        exports.updateUnreadCount(feed);
        WEBR.Display.updateUnreadCount(feed);
        WEBR.Notify.show(addedFeeds + ' new article' + ((addedFeeds == 1) ? '' : 's') + ' added.', 1500);
        WEBR.Display.refreshArticleList(feed);
        exports.saveFeedList();
        exports.saveFeedContent(feed.rss);
    }
    
    function onErr(err) {
        //console.log('Error pulling feed ' + feed.name + ':');
        //console.log(err);
    }
    
    util.fetchFeed(feed.rss, onDone, onErr);
}

exports.pullAllFeeds = function (force) {
    addedFeeds = 0;
    if (force || (new Date().getTime() > settings.lastUpdate + settings.updateRate)) {
        if (new Date().getTime() < settings.lastUpdate + 30000) {
            return; // minimum 30 secs wait
        }
        WEBR.Notify.show('Pulling all feeds.', 1500);
        exports.saveSettings();
        for (var i in feeds) {
            pullFeed(feeds[i]);
        }
        setTimeout(function () {
            db.persistence.compactDatafile();
        }, 2000);
        settings.lastUpdate = new Date().getTime();
    }
}

exports.addFeed = function (name, url, append, sel, remove) {
    if (url == 'saved' || url.slice(0, 4) != 'http') {
        WEBR.Notify.show('Invalid feed URL.', 1500);
        return false;
    }
    
    // prevent duplicate RSS link
    for (var i in feeds) {
        if (feeds[i].rss == url) {
            WEBR.Notify.show('RSS URL already in feed list!', 2000);
            return false;
        }
    }
    
    // add new feed
    var newFeed = { name: name, rss: url, append: append, sel: sel, remove: remove };
    feeds.push(newFeed);
    exports.saveFeedList();
    pullFeed(newFeed);
    WEBR.Notify.show('Feed added successfully.', 1600);
    return true;
}

exports.removeFeed = function (feed) {
    if (!feed) return false;
    var ind = exports.getFeedIndex(feed);
    if (ind >= 0 && ind < feeds.length) {
        feeds.splice(ind, 1);
        if (content[feed.rss]) {
            delete content[feed.rss];
        }
        exports.saveFeedList();
        exports.deleteFeedContent(feed.rss);
        return true;
    }
    return false;
}


exports.isArticleSaved = function (post) {
    if (!post) return false;
    return isArticleInList(post.link, content[savedFeed.rss]);
}

exports.saveArticle = function (post, article) {
    if (!post) return false;
    if (exports.findPost(savedFeed, post.link)) return false;
    
    var posts = content[savedFeed.rss];
    
    var newpost = { id: settings.nextSavedFeedId++, title: post.title, desc: post.desc, link: post.link, date: post.date, read: new Date(), article: article };
    if (posts) {
        posts.unshift(newpost);
    } else {
        content[savedFeed.rss] = [newpost];
    }
    exports.saveSettings();
    return true;
}

exports.unsaveArticle = function (post) {
    if (!post) return false;
    
    var posts = content[savedFeed.rss];
    if (!posts) return false;
    
    for (var i = 0; i < posts.length; i++) {
        if (posts[i].link == post.link) {
            posts.splice(i, 1);
            return true;
        }
    }
    return false;
}


exports.markAllAsRead = function (feed) {
    if (!feed) return 0;
    var posts = content[feed.rss];
    if (!posts) return 0;
    
    var updated = 0;
    for (var i in posts) {
        if (!posts[i].read)  {
            posts[i].read = new Date();
            updated++;
        }
    }
    feed.unread = 0;
    if (updated > 0) {
        exports.saveFeedContent(feed.rss);
        WEBR.Display.refreshArticleList(feed);
    }
    return updated;
}

exports.updateUnreadCount = function(feed) {
    if (!feed) return;
    feed.unread = 0;
    
    var posts = content[feed.rss],
        unread = 0;
    if (!posts) return;
    
    for (var i = 0; i < posts.length; i++) {
        if (!posts[i].read) {
            unread++;
        }
    }
    feed.unread = unread;
}

exports.updateAllUnreadCounters = function() {
    for (var i in feeds) {
        exports.updateUnreadCount(feeds[i]);
    }
}


// -------------- loading and saving ----------------

// loads settings, feed list, feed content from database
exports.loadData = function (webr_instance, nwgui, callback) {
    
    WEBR = webr_instance;
    datapath = nwgui.App.dataPath;
    db = new DataStore({ filename: path.join(datapath, 'db.db'), autoload: true });
    
    function repositionWindow() {
        var win = nwgui.Window.get();
        if (settings.posX != -1 && settings.posY != -1) {
            win.moveTo(settings.posX, settings.posY);
        }
        win.resizeTo(settings.sizeX, settings.sizeY);
    }
    
    function loadFeedContent() {
        db.find({feed: true}, function (err, docs) {
            if (!err && docs) {
                for (var i in docs) {
                    content[docs[i].feedname] = docs[i].content;
                }
            }
            //console.log(docs);
            exports.updateAllUnreadCounters();
            callback();
        });
    }
    
    function loadFeedList() {
        db.findOne({_id: 'feeds'}, function (err, doc) {
            if (!err && doc) {
                var fds = doc.feeds;
                for (var i in fds) {
                    if (fds.hasOwnProperty(i)) {
                        feeds[i] = fds[i];
                    }
                }
            }
            //console.log(doc);
            loadFeedContent();
        });
    }
    
    db.findOne({_id: 'settings'}, function (err, doc) {
        var att, s;
        //console.log(doc);
        if (!err && doc) {
            s = doc.settings;
            for (att in s) {
                if (s.hasOwnProperty(att)) {
                    settings[att] = s[att];
                }
            }
        }
        repositionWindow();
        loadFeedList();
    });
};

exports.savePosition = function (pX, pY, sX, sY) {
    settings.posX = pX;
    settings.posY = pY;
    settings.sizeX = sX;
    settings.sizeY = sY;
    exports.saveSettings();
}

exports.saveSettings = function() {
    db.update({ _id: 'settings' }, { settings: settings }, { upsert: true });
}

exports.saveFeedList = function() {
    db.update({ _id: 'feeds' }, { feeds: feeds }, { upsert: true });
}

exports.saveFeedContent = function (feedurl) {
    if (content[feedurl]) {
        db.update({ feedname: feedurl }, { feed: true, feedname: feedurl, content: content[feedurl] }, { upsert: true });
    }
}

exports.deleteFeedContent = function (feedurl) {
    db.remove({ feed: true, feedname: feedurl }, {}, function (err, num) {
        //console.log('Deleted feed from nedb: ' + feedurl);
    });
}

exports.saveAllFeedContent = function() {
    for (var i in content) {
        if (content.hasOwnProperty(i)) {
            db.update({ feedname: i }, { feed: true, feedname: i, content: content[i] }, { upsert: true });
        }
    }
}
