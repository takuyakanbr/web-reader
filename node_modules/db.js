
var DataStore = require('nedb'),
    path = require('path'),
    util = require('utils'),
    WEBR = null,
    datapath = null,
    db = null,
    settings = {
        updateRate: 1000 * 60 * 60, // 1 hour
        lastUpdate: 0,
        removeOlderThan: 1000 * 60 * 60 * 24 * 10, // 10 days
        lastRemove: 0
    },
    suggestions = [ // { name, rss, append, sel, remove, lastupdate, lastlink, nextid, unread, read }
        {name: 'BBC News', rss: 'http://feeds.bbci.co.uk/news/rss.xml?edition=int', sel: 'div.story-body', remove: 'div.share-help'},
        {name: 'TODAY Online', rss: 'http://www.todayonline.com/taxonomy/term/3/all/feed', append: '?singlepage=true', sel: 'article.article|div.content p'},
        {name: 'ArsTechnica', rss: 'http://feeds.arstechnica.com/arstechnica/index', sel: 'section#article-guts'},
        {name: 'The Verge', rss: 'http://www.theverge.com/rss/full.xml', sel: 'div.article-body|div#feature-body'},
        {name: 'Aeon Magazine', rss: 'http://feeds.feedburner.com/AeonMagazineEssays', sel: 'div.masthead-image|div.content', remove: 'div.aeon-popular-panel|div.shortcode-inline-newsletter'},
        {name: 'XKCD', rss: 'http://www.xkcd.com/rss.xml'},
        {name: 'Merriam-Webster Word of the Day', rss: 'http://www.merriam-webster.com/word/index.xml'},
        {name: 'TED - Youtube', rss: 'http://gdata.youtube.com/feeds/base/users/TEDtalksDirector/uploads?alt=rss&v=2&orderby=published&client=ytapi-youtube-profile'}
    ],
    feeds = [ ], // { name, rss, append, sel, remove, lastupdate, lastlink, nextid }
    content = {}; // [ id, title, desc, link, date, read ]


// returns a feed object given an RSS URL, or null if none is found
exports.findFeed = function (url) {
    for (var i in feeds) {
        if (feeds[i].rss == url)
            return feeds[i];
    }
    return null;
}

// returns a post object given feed url and article url, or null if none is found
exports.findPost = function (feed, articleUrl) {
    if (!feed) return null;
    var posts = content[feed.rss];
    if (!posts || posts.length == 0) {
        return null;
    }
    
    for (var i in posts) {
        if (posts[i].link == articleUrl)
            return posts[i];
    }
    return null;
}


function isArticleInList(link, posts) {
    if (!posts) {
        return false;
    }
    for (var i in posts) {
        if (posts[i].link == link) {
            return true;
        }
    }
    return false;
}

function pullFeed(feed) {
    if (!feed.nextid) feed.nextid = 1;
    if (!feed.read) feed.read = 0;
    if (!feed.lastlink) feed.lastlink = '[none]';
    
    function onDone(posts, meta) {
        if (posts.length == 0) {
            return;
        }
        
        // extract data and ensure no duplicates
        var newPosts = [];
        for (var i in posts) {
            if (posts[i].link == feed.lastlink) {
                break;
            }
            if (isArticleInList(posts[i].link, content[feed.rss])) {
                continue;
            }
            var p = { title: posts[i].title, desc: posts[i].description, link: posts[i].link, date: posts[i].pubdate };
            if (!p.date) {
                p.date = new Date();
            }
            newPosts.push(p);
        }
        
        // assign IDs
        if (newPosts.length == 0) {
            return;
        }
        for (var i = newPosts.length - 1; i >= 0; i--) {
            newPosts[i].id = feed.nextid++;
        }
        
        // update stored data
        feed.lastlink = newPosts[0].link;
        feed.lastupdate = new Date();
        if (content[feed.rss]) {
            content[feed.rss] = newPosts.concat(content[feed.rss]);
        } else {
            content[feed.rss] = newPosts;
        }
        
        // save to database
        updateUnreadCount(feed);
        WEBR.Display.updateFeedUnread(feed);
        WEBR.Notify.show('New articles added.', 1500);
        exports.saveFeedList();
        exports.saveFeedContent(feed.rss);
    }
    
    function onErr(err) {
        console.log('Error loading feed ' + feed.name + ':');
        console.log(err);
    }
    
    util.fetchFeed(feed.rss, onDone, onErr);
}

function pullAllFeeds(force) {
    if (force || (new Date().getTime() > settings.lastUpdate + settings.updateRate)) {
        if (new Date().getTime() < settings.lastUpdate + 30000) {
            return; // minimum 30 secs wait
        }
        console.log('Pulling all feeds.');
        WEBR.Notify.show('Pulling all feeds.', 1500);
        exports.saveSettings();
        for (var i in feeds) {
            pullFeed(feeds[i]);
        }
        settings.lastUpdate = new Date().getTime();
    }
}
exports.pullAllFeeds = pullAllFeeds;

exports.addFeed = function (name, url, append, sel, remove) {
    // prevent duplicate RSS link
    for (var i in feeds) {
        if (feeds[i].rss == url) {
            WEBR.Notify.show('RSS URL already in feed list!', 2000);
            return;
        }
    }
    
    // add new feed
    WEBR.Notify.show('Feed added successfully.', 1600);
    var newFeed = { name: name, rss: url, append: append, sel: sel, remove: remove };
    feeds.push(newFeed);
    pullFeed(newFeed);
}


function updateUnreadCount(feed) {
    feed.unread = 0;
    
    var posts = content[feed.rss],
        unread = 0;
    if (!posts) return;
    
    for (var i in posts) {
        if (!posts[i].read) {
            unread++;
        }
    }
    feed.unread = unread;
}
exports.updateUnreadCount = updateUnreadCount;

function updateUnreadCounters() {
    for (var i in feeds) {
        updateUnreadCount(feeds[i]);
    }
}


// -------------- loading and saving ----------------

// loads settings, feed list, feed content from database
exports.loadData = function (webr_instance, nwgui, callback) {
    
    WEBR = webr_instance;
    datapath = nwgui.App.dataPath;
    db = new DataStore({ filename: path.join(datapath, 'db.db'), autoload: true });
    
    function loadFeedContent() {
        db.find({feed: true}, function (err, docs) {
            if (!err && docs) {
                for (var i in docs) {
                    content[docs[i].feedname] = docs[i].content;
                }
            }
            console.log(docs);
            updateUnreadCounters();
            callback();
        });
    }
    
    function loadFeedList() {
        db.findOne({_id: 'feeds'}, function (err, doc) {
            if (!err && doc) {
                var fds = doc.feeds;
                for (var i in fds) {
                    if (fds.hasOwnProperty(i)) {
                        feeds[i] = fds[i];
                    }
                }
            }
            console.log(doc);
            loadFeedContent();
        });
    }
    
    db.findOne({_id: 'settings'}, function (err, doc) {
        var att, s;
        console.log(doc);
        if (!err && doc) {
            s = doc.settings;
            for (att in s) {
                if (s.hasOwnProperty(att)) {
                    settings[att] = s[att];
                }
            }
        }
        loadFeedList();
    });
};

exports.saveSettings = function() {
    db.update({ _id: 'settings' }, { settings: settings }, { upsert: true });
}

exports.saveFeedList = function() {
    db.update({ _id: 'feeds' }, { feeds: feeds }, { upsert: true });
}

exports.saveFeedContent = function (feedurl) {
    if (content[feedurl]) {
        db.update({ feedname: feedurl }, { feed: true, feedname: feedurl, content: content[feedurl] }, { upsert: true });
    }
}

exports.saveAllFeedContent = function() {
    for (var i in content) {
        if (content.hasOwnProperty(i)) {
            db.update({ feedname: i }, { feed: true, feedname: i, content: content[i] }, { upsert: true });
        }
    }
}



exports.db = db;
exports.settings = settings;
exports.feeds = feeds;
exports.content = content;
